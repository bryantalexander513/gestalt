# These types are auto-generated for every schema

schema {
  mutation: MutationRoot
  query: QueryRoot
}

type QueryRoot {
  node(id: ID!): Node
  session: Session
}

type MutationRoot {
  # mutations...
  # these are created directly w/ javsscript and do not need to be defined using
  # the IDL
}
# mutation input and payload types...

interface Node {
  id: ID!
}

# These extra scalar types (mapping to database types) are added to the graphql
# schema if used in definitions.
scalar Date
scalar Money
scalar Text
scalar Geo

# These directives are used to provide information on resolving types
directive @description(text: String) on SCALAR | OBJECT | INTERFACE | UNION |
  ENUM | INPUT_OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE |
  INPUT_FIELD_DEFINITION
directive @depreciated(reason: String) on FIELD_DEFINITION
directive @computed on FIELD_DEFINITION
directive @hidden on FIELD_DEFINITION
directive @edge(path: String) on FIELD_DEFINITION

# The folloing types are an example of what would defined by the user through
# using the IDL.

type Session {
  # Values defined on session are set through mutations.  Nodes are stored by
  # by ID, scalars and non node object types are serialized and stored directly.

  # Node IDs are random in a large enough range so as not to be guessable. This
  # lets us avoid any extra checking when querying nodes directly from the query
  # root. Security is achieved by avoiding making any private information
  # reachable from the Session type.

  currentUser: User
}


# Types implementing the Node interface become database tables.  Non node types
# are stored directly as JSON in columns on Nodes.

type User implements Node
@description(text: "A registered user of our app")
{

  # scalar types are defined using the normal GraphQL IDL - these create both
  # columns in the database and fields in the GraphQL schema

  id: ID!
  firstName: String
  lastName: String
  createdAt: Date!

  # The directive @hidden marks fields that should be part of the database
  # schema and available to application code, but that should not be part of the
  # GraphQL schema.  In this case we want to store passwordHash in the database
  # for authorization, but never to expose it to the client.

  email: String! @hidden
  passwordHash: String! @hidden

  # The directive @computed marks fields that are part of the GraphQL schema but
  # are not stored to the database.  Resolution of these fields is defined in
  # javascript seperatey.  In this case we can compute fullName from the
  # firstName and lastName columns, so don't need to store it seperately.

  fullName: String @computed


  # Relationships between nodes are defined w/ an arrow notation inspired by the
  # Cypher query language from Neo4j.  Fat arrows `=>` are plural and result in
  # Relay connections (with connection types generated automatically).  Thin
  # arrows `->` are singular and refer to the object type directly.

  # Relationships are matched to their inverses using their labels and arrow
  # directions. This will let us automatically determine which on which table
  # to put the foreign key, and how to index.  Combinations of label, direction,
  # and related type cannot be repeated on a type.

  # with this many to many relationship, we would end up w/ a join table
  # user_followed_users.

  followedUsers: User @edge(path: "=FOLLOWED=>")
  followers: User @edge(path: "<=FOLLOWED=")

  # the corresponding author fields on Posts and comments are singular, so for
  # these connections we know to add user_authored_id on the posts and comments
  # tables.

  posts: Post @edge(path: "=AUTHORED=>")
  comments: Comment @edge(path: "=AUTHORED=>")

  # We can define fields that follow multiple relationships as shown.  This
  # would result in multiple joins (to user_followed_users, users, and posts).

  feed: Post @edge(path: "=FOLLOWED=>User=AUTHORED=>")
}

type Post implements Node
@description(text: "Posts written by users")
{
  id: ID!
  title: String!
  text: String!
  createdAt: Date!
  author: User @edge(path: "<-AUTHORED-")
  comments: Comment @edge(path: "<=COMMENT_ON=")
}

type Comment implements Node
@description(text: "Comments on posts")
{
  id: ID!
  text: String!
  createdAt: Date!
  author: User @edge(path: "<-AUTHORED-")
  subject: Post @edge(path: "-COMMENT_ON->")
}
