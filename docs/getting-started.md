Getting Started With Gestalt
============================

This will walk you through creating a simple twitter clone from scratch using
Gestalt.



Prerequisites:
--------------

You will need Node, NPM, and PostgreSQL, and to make sure that postgres is
running.

If you don't have [postgres](https://www.postgresql.org/) already, the easiest
way to install it on a mac is with [homebrew](http://brew.sh/).



Steps:
------


#### 1) Install gestalt-cli

`npm install --global gestalt-cli`

`gestalt-cli` is a module that will help you scaffold new projects and run
database migrations.  Installing it globally with npm will allow you to use
the `gestalt` command on the command line.


#### 2) Create your database

`createdb blogs`

We will need a PostgreSQL database for our app to connect to.  You can create
one with the `createdb` command.  Let's name it 'blogs'.


#### 3) Create a new Gestalt project:

`gestalt init blogs`

This will create a new directory `blogs`, install `gestalt-server`,
`gestalt-postgres`, and a few other necessary modules, and create the
boilerplate files for a simple express app running a GraphQL API.

The Gestalt CLI will prompt you for a database url.  Because we already created
a database matching the name of our project (`'blogs'`), you can just hit enter
to use the default url (`'postgres://localhost/blogs'`).


#### 4) Edit schema.graphql

`gestalt init` will have created a simple `schema.graphql` file with an object
type named 'Session'.

```graphql
type Session {
  id: ID!
}
```

We will use `Session` later, but for now let's add some types to our schema to
represent users and posts:

```graphql
type Session {
  id: ID!
}

type User implements Node {
  id: ID!
  email: String! @unique
  passwordHash: String! @hidden
}

type Post implements Node {
  id: ID!
  text: String!
  createdAt: Date!
}
```

This adds a type named `User` to our schema with fields `id` and `email`.  We
added the `@unique` directive to email to tell the database to enforce its
uniqueness, and the `@hidden` directive to the `passwordHash` field to create a
column in the database, but *not* a field in our GraphQL schema.


#### 5) Run database migrations: `cd your-project` and `gestalt migrate`

When you run `gestalt-migrate` in the root directory of yourÂ project, Gestalt
reads the existing database schema, compares it to what is defined in
`schema.graphql`, and generates a migration to update the database.  This
migration will only add (not drop) columns or tables for safety, and you can
have the cli run it directly or write it to a file.

After our additions to `schema.graphql`, `gestalt migrate` will ask to confirm
our database url, and then generate and print the following SQL migration:

```SQL
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE users (
  seq SERIAL NOT NULL UNIQUE,
  id uuid PRIMARY KEY,
  email text NOT NULL UNIQUE,
  password_hash text NOT NULL
);

CREATE TABLE posts (
  seq SERIAL NOT NULL UNIQUE,
  id uuid PRIMARY KEY,
  text text NOT NULL,
  created_at timestamp without time zone NOT NULL
);
```

A couple things are going on here - first Gestalt needs to add the `'pgcrypto'`
extension because we will use it to generate uuids (I'll explain more about this
later), and then we are creating tables for the two types we added, `users` and
`posts`.

Looking first at the `users` table, the email and password hash columns are
straightforward. We can see that the `email` column is `UNIQUE` because we added
the `@unique` directive, and that both of the columns have type `text`
corresponding to `String` in our GraphQL schema.

The `id` and `seq` columns could be a little surprising.  You might expect a
single column `id SERIAL PRIMARY KEY` for the `id` field.  Instead `id` has
type `uuid`, and we have an additional column `seq` with type `SERIAL`.

The reason we use UUIDs for node ids is that it lets us query nodes by id
without needing to define extra permission checks.  UUIDs generated by
`pgcrypto` are securely random, so users will only be able to see nodes we
deliberately expose to them.

And then because our ids are random, we include the `seq` column to record the
order that rows were created so that we can order them chronologically.

You can type `'yes'` to run the migration, and then `'no'` to skip writing it to
a file.  At this point, you should be able to start the server and explore your
schema in the GraphiQL IDE.  Run `npm start` and navigate to
`localhost:3000/graphql`.


#### 6) Add the `AUTHORED` relationship between users and posts:

We will also want to record the author of each post, and be able to see all of
the posts that any user authored.  We can add this to our schema using the
`@relationship` directive.

```graphql
type Session {
  id: ID!
}

type User implements Node {
  id: ID!
  email: String! @unique
  passwordHash: String! @hidden
  posts: Post @relationship(path: "=AUTHORED=>")
}

type Post implements Node {
  id: ID!
  text: String!
  createdAt: Date!
  author: User @relationship(path: "<-AUTHORED-")
}
```

Here we have added the `posts` field to the `User` type, and the `author` field
to the `Post` type.

Gestalt will look at the `@relationship` directives on these fields, and match
them because they have the same label, `AUTHORED`, and point in opposite
directions.

The 'fat' arrow using the `=` character on the `posts` field indicates that the
field is plural (a user can author many posts) and the 'skinny' arrow (using
`-`) on the `author` field indicates that that field is singular (a post has
only one author).

Gestalt can figure out that best way to represent this one to many relationship
is to add a foreign key to the `posts` table referencing `users` and storing the
id of its author.

After making these changes to `schema.graphql`, run `gestalt-migrate` again. It
will create the following migration:

```SQL
ALTER TABLE posts ADD COLUMN authored_by_user_id uuid;

CREATE INDEX ON posts (authored_by_user_id);
```

We can see that it's adding the foreign key column we expect,
`authored_by_user_id`, and adding an index on it.  Type `'yes'` to run the
migration.  After running it, if you restart your server you should see the
`posts` field on `User` and `author` field on `Posts` show up in GraphiQL.

One thing you will notice is that the type of the `posts` field on `User` is
`PostsConnection` and not `Post`.  


#### 7) Add the `FOLLOWED` relationship between users:

```graphql
type User implements Node {
  ...
  followedUsers: User @relationship(path: "=FOLLOWED=>")
  followers: User @relationship(path: "<=FOLLOWED=")
 }
```

this will result in the following migration:

```
CREATE TABLE user_followed_users (
  user_id uuid NOT NULL REFERENCES users (id),
  followed_user_id uuid NOT NULL REFERENCES users (id),
  UNIQUE (user_id, followed_user_id)
);

CREATE INDEX ON user_followed_users (followed_user_id);
```

#### 8) Add the `feed` field to `User`:

```graphql
type User implements Node {
  ...
  feed: Post @relationship(path: "=FOLLOWED=>User=AUTHORED=>")
 }
```

#### 9) Add a `gravatar` field to `User` with custom resolution

```
type User implements Node {
  ...
  gravatar: String! @virtual
}
```

```javascript
import crypto from 'crypto';

export default {
  name: 'User',
  fields: {
    // get a user's gravatar image url using their email address
    gravatar: (obj, args) => {
      const email = obj.email.toLowerCase();
      const hash = crypto.createHash('md5').update(email).digest('hex');
      return `//www.gravatar.com/avatar/${hash}?d=mm&s=${args.size || 200}`;
    },
  },
};
```

#### 8) Add `currentUser` to the `Session` type

```
type Session {
  id: ID!
  currentUser: User
}
```

```javascript
export default {
  name: 'Session',
  fields: {
    id: () => '!',
    currentUser: (obj, args, context) => {
      if (obj.currentUserID == null) { return null; }
      return context.db.findBy('users', {id: obj.currentUserID});
    },
  },
};
```


#### 9) create `SignIn` and `SignOut` mutations

You can create mutations in the mutations directory, and your server will load
them automatically.

```javascript
import bcrypt from 'bcrypt-as-promised';

export default types => ({
  name: 'SignIn',
  inputFields: {
    email: types.String,
    password: types.String,
  },
  outputFields: {
    session: types.Session,
  },
  mutateAndGetPayload: async (input, context) => {
    const {email, password} = input;
    const {db, session} = context;

    try {
      const user = await db.findBy('users', {email});
      await bcrypt.compare(password, user.passwordHash);
      session.currentUserID = user.id;
      return {session};
    } catch (e) {
      throw 'Email or password is invalid';
    }
  },
});
```

```javascript
export default types => ({
  name: 'SignOut',
  inputFields: {},
  outputFields: {
    session: types.Session,
  },
  mutateAndGetPayload: (input, context) => {
    const {session} = context;
    session.currentUserID = null;
    return {session};
  },
});
```

#### 10) create `SignUp` and `CreatePost` mutations

```javascript
import bcrypt from 'bcrypt-as-promised';
import assert from 'assert';

export default types => ({
  name: 'SignUp',
  inputFields: {
    email: types.String,
    password: types.String,
  },
  outputFields: {
    session: types.Session,
  },
  mutateAndGetPayload: async (input, context) => {
    const {email, password} = input;
    const {db, session} = context;

    assert(email.match(/.+@.+?\..+/), 'Email is invalid');
    assert(password.length > 5, 'Password is invalid');

    const passwordHash = await bcrypt.hash(password, 10);
    const user = await db.insert('users', {
      email,
      passwordHash,
    });

    session.currentUserID = user.id;
    return {session};
  },
});
```

```javascript
import assert from 'assert';

export default types => ({
  name: 'CreatePost',
  inputFields: {
    title: types.String,
    text: types.String,
  },
  outputFields: {
    user: types.User,
  },
  mutateAndGetPayload: async (input, context) => {
    const {title, text} = input;
    const {db, session} = context;
    const {currentUserID} = session;

    assert(title.length > 0, 'Posts must have titles');
    assert(text.length > 0, 'Posts must have text');

    const user = await db.findBy('users', {id: currentUserID});

    const post = await db.insert('posts', {
      createdAt: new Date(),
      authoredByUserID: currentUserID,
      title,
      text,
    });

    return {user};
  },
});
```

#### 11) Create `FollowUser` and `UnfollowUser` mutations

```javascript
export default types => ({
  name: 'FollowUser',
  inputFields: {
    userID: types.ID,
    follow: types.Boolean,
  },
  outputFields: {
    user: types.User,
    currentUser: types.User
  },
  mutateAndGetPayload: async (input, context) => {
    const {follow, userID} = input;
    const {db, session} = context;
    const {currentUserID} = session;
    const followedUserID = userID.split(':')[1];

    if (follow) {
      await db.exec(
        'INSERT INTO user_followed_users (user_id, followed_user_id) ' +
        'VALUES ($1, $2);',
        [currentUserID, followedUserID]
      );
    } else {
      await db.deleteBy(
        'user_followed_users',
        {userId: currentUserID, followedUserID}
      );
    }

    const currentUser = await db.findBy('users', {id: currentUserID});
    const user = await db.findBy('users', {id: followedUserID});

    return {currentUser, user};
  },
});
```

#### 12) Create a front end

This step is beyond the scope of this walkthrough..  Now that you have a
complete API you could build a frontend (or many!) on any platform you like.  If
you want to take a look at an example frontend built using react and relay, you
can [find one here](//github.com/charlieschwabacher/gestalt/tree/master/packages/blogs-example).
